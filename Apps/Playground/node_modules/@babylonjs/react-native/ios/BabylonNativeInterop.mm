#import "BabylonNativeInterop.h"
#import "BabylonNative.h"

#import <React/RCTBridge+Private.h>
#import <jsi/jsi.h>

#import <Foundation/Foundation.h>

#import <functional>
#import <memory>
#import <vector>
#import <unordered_map>
#import <mutex>

using namespace facebook;

namespace {
    jsi::Runtime* GetJSIRuntime(RCTBridge* bridge) {
        RCTCxxBridge* cxxBridge = reinterpret_cast<RCTCxxBridge*>(bridge);
        return reinterpret_cast<jsi::Runtime*>(cxxBridge.runtime);
    }
}

@implementation BabylonNativeInterop

static RCTBridge* currentBridge;
static MTKView* currentView;
static std::unique_ptr<Babylon::Native> currentNativeInstance;
static std::unordered_map<void*, std::vector<RCTPromiseResolveBlock>> initializationPromises;
static std::mutex mapMutex;

+ (void)setView:(RCTBridge*)bridge jsRunLoop:(NSRunLoop*)jsRunLoop mktView:(MTKView*)mtkView width:(int)width height:(int)height {
    // NOTE: jsRunLoop should only be null when remote debugging is enabled.
    //       In this case, we can just use the main loop, because we are only
    //       going to set an error state (which can happen on any thread).
    if (!jsRunLoop) {
        jsRunLoop = NSRunLoop.mainRunLoop;
    }

    [jsRunLoop performBlock:^{
        if (bridge != currentBridge) {
            currentBridge = bridge;
            currentView = mtkView;
            [BabylonNativeInterop setNativeInstance:currentView width:width height:height];
        } else if (currentNativeInstance) {
            if (mtkView != currentView) {
                currentView = mtkView;
                currentNativeInstance->Refresh((__bridge void*)currentView, width, height);
            } else {
                //currentNativeInstance->Resize(width, height);
            }
        }
    }];
}

+ (void)whenInitialized:(RCTBridge*)bridge resolve:(RCTPromiseResolveBlock)resolve {
    if (bridge == currentBridge) {
        resolve([NSNumber numberWithUnsignedLong:reinterpret_cast<uintptr_t>(currentNativeInstance.get())]);
    } else {
        initializationPromises[(__bridge void*)bridge].push_back(resolve);
    }
}

+ (void)setNativeInstance:(MTKView*)mtkView width:(int)width height:(int)height {
    const std::lock_guard<std::mutex> lock(mapMutex);

    currentNativeInstance.reset();
    
    jsi::Runtime* jsiRuntime = GetJSIRuntime(currentBridge);
    if (jsiRuntime) {
        currentNativeInstance = std::make_unique<Babylon::Native>(GetJSIRuntime(currentBridge), (__bridge void*)mtkView, width, height);
    }

    auto initializationPromisesIterator = initializationPromises.find((__bridge void*)currentBridge);
    if (initializationPromisesIterator != initializationPromises.end()) {
        for (RCTPromiseResolveBlock resolve : initializationPromisesIterator->second) {
            resolve([NSNumber numberWithUnsignedLong:reinterpret_cast<uintptr_t>(currentNativeInstance.get())]);
        }

        initializationPromises.erase(initializationPromisesIterator);
    }
}

@end
