#import "BabylonNativeInterop.h"
#import "BabylonNative.h"

#import <React/RCTBridge+Private.h>
#import <jsi/jsi.h>

#import <Foundation/Foundation.h>

#import <functional>
#import <memory>
#import <vector>
#import <unordered_map>
#import <mutex>

using namespace facebook;

namespace {
    jsi::Runtime* GetJSIRuntime(RCTBridge* bridge) {
        RCTCxxBridge* cxxBridge = reinterpret_cast<RCTCxxBridge*>(bridge);
        return reinterpret_cast<jsi::Runtime*>(cxxBridge.runtime);
    }
}

@implementation BabylonNativeInterop

static std::unordered_map<jsi::Runtime*, Babylon::Native*> nativeInstances;
static std::unordered_map<jsi::Runtime*, std::vector<RCTPromiseResolveBlock>> initializationPromises;
static std::mutex mapMutex;

+ (void)setView:(RCTBridge*)bridge jsRunLoop:(NSRunLoop*)jsRunLoop mktView:(void*)mktView width:(int)width height:(int)height {
    // TODO: destroy old instances

    [jsRunLoop performBlock:^{
        jsi::Runtime* jsiRuntime = GetJSIRuntime(bridge);
        auto nativeInstancesIterator = nativeInstances.find(jsiRuntime);
        if (nativeInstancesIterator == nativeInstances.end()) {
            if (jsiRuntime == nullptr) {
                // TODO: If we don't have a jsi runtime (due to remote debugging), set the native pointer to null (maybe key should be the bridge? does the bridge instance change on reload?)
            } else {
                [BabylonNativeInterop addNativeInstance:jsiRuntime babylonNative:new Babylon::Native(jsiRuntime, mktView, width, height)];
            }

        } else if (nativeInstancesIterator->second) {
            nativeInstancesIterator->second->Refresh(mktView, width, height);
        }
    }];
}

+ (void)whenInitialized:(RCTBridge*)bridge resolve:(RCTPromiseResolveBlock)resolve {
    jsi::Runtime* jsiRuntime = GetJSIRuntime(bridge);
    if (jsiRuntime) {
        const std::lock_guard<std::mutex> lock(mapMutex);
        auto nativeInstancesIterator = nativeInstances.find(jsiRuntime);
        if (nativeInstancesIterator == nativeInstances.end()) {
            initializationPromises[jsiRuntime].push_back(resolve);
        } else {
            resolve([NSNumber numberWithUnsignedLong:reinterpret_cast<uintptr_t>(nativeInstancesIterator->second)]);
        }
    }
}

+ (void)addNativeInstance:(jsi::Runtime*)jsiRuntime babylonNative:(Babylon::Native*)babylonNative {
    const std::lock_guard<std::mutex> lock(mapMutex);

    nativeInstances[jsiRuntime] = babylonNative;

    auto initializationPromisesIterator = initializationPromises.find(jsiRuntime);
    if (initializationPromisesIterator != initializationPromises.end()) {
        for (RCTPromiseResolveBlock resolve : initializationPromisesIterator->second) {
            resolve([NSNumber numberWithUnsignedLong:reinterpret_cast<uintptr_t>(babylonNative)]);
        }

        initializationPromises.erase(initializationPromisesIterator);
    }
}

@end
