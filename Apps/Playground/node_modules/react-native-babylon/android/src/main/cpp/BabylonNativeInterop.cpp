#include <jni.h>

#include <Babylon/JsRuntime.h>
#include <Babylon/Plugins/NativeWindow.h>
#include <Babylon/Plugins/NativeEngine.h>
#include <Babylon/Plugins/NativeInput.h>
#include <Babylon/Polyfills/Window.h>

#include <arcana/threading/task_schedulers.h>

#include <JavaScriptCore/JavaScript.h>
#include <jsi/jsi.h>

#include <android/log.h>
#include <android/native_window.h>
#include <android/native_window_jni.h>

#include <optional>
#include <sstream>
#include <unistd.h>

#include <jsi/jsi.h>

// HACK!
#include "JSCRuntime.h"

namespace Babylon
{
    namespace
    {
        void log(const char *str)
        {
            __android_log_print(ANDROID_LOG_VERBOSE, "BabylonNative", "%s", str);
        }
    }

    class Native final
    {
    public:
        // This class must be constructed from the JavaScript thread
        Native(facebook::jsi::Runtime* jsiRuntime, ANativeWindow* windowPtr)
        : m_env{ Napi::Attach(jsiRuntime) }
        {
            auto looper_scheduler = std::make_shared<looper_scheduler_t>(looper_scheduler_t::get_for_current_thread());

            JsRuntime::DispatchFunctionT dispatchFunction{[env = m_env, looper_scheduler = std::move(looper_scheduler)](std::function<void(Napi::Env)> func) {
                (*looper_scheduler)([env, func = std::move(func)]()
                {
                    func(env);
                });
            }};

            m_runtime = &JsRuntime::CreateForJavaScript(m_env, dispatchFunction);

            auto width = static_cast<size_t>(ANativeWindow_getWidth(windowPtr));
            auto height = static_cast<size_t>(ANativeWindow_getHeight(windowPtr));

            Plugins::NativeEngine::InitializeGraphics(windowPtr, width, height);
            Plugins::NativeEngine::Initialize(m_env);
            Plugins::NativeWindow::Initialize(m_env, windowPtr, width, height);

            Polyfills::Window::Initialize(m_env);

            m_nativeInput = &Babylon::Plugins::NativeInput::CreateForJavaScript(m_env);

            // TODO: This shouldn't be necessary, but for some reason results in a significant increase in frame rate. Need to figure this out.
            Plugins::NativeEngine::Reinitialize(m_env, windowPtr, width, height);
        }

        ~Native()
        {
            Plugins::NativeEngine::DeinitializeGraphics();
        }

        void Refresh(ANativeWindow* windowPtr)
        {
            auto width = static_cast<size_t>(ANativeWindow_getWidth(windowPtr));
            auto height = static_cast<size_t>(ANativeWindow_getHeight(windowPtr));
            Plugins::NativeEngine::Reinitialize(m_env, windowPtr, width, height);
        }

        void SetPointerButtonState(uint32_t pointerId, uint32_t buttonId, bool isDown, uint32_t x, uint32_t y)
        {
            if (isDown)
            {
                m_nativeInput->PointerDown(pointerId, buttonId, x, y);
            }
            else
            {
                m_nativeInput->PointerUp(pointerId, buttonId, x, y);
            }
        }

        void SetPointerPosition(uint32_t pointerId, uint32_t x, uint32_t y)
        {
            m_nativeInput->PointerMove(pointerId, x, y);
        }

    private:
        using looper_scheduler_t = arcana::looper_scheduler<sizeof(std::weak_ptr<Napi::Env>) + sizeof(std::function<void(Napi::Env)>)>;
        Napi::Env m_env;
        JsRuntime* m_runtime;
        Plugins::NativeInput* m_nativeInput;
    };
}

std::unique_ptr<facebook::jsi::Runtime> g_jsiRuntime{};

extern "C" JNIEXPORT jlong JNICALL Java_com_reactlibrary_BabylonNativeInterop_create(JNIEnv* env, jclass obj, jlong jsContextHandle, jlong jsContextRef, jobject surface)
{
    g_jsiRuntime = facebook::jsc_hack::makeJSCRuntime(reinterpret_cast<JSGlobalContextRef>(jsContextRef));

    ANativeWindow* windowPtr = ANativeWindow_fromSurface(env, surface);
    auto native = new Babylon::Native(g_jsiRuntime.get(), windowPtr);
    return reinterpret_cast<intptr_t>(native);
}

extern "C" JNIEXPORT void JNICALL Java_com_reactlibrary_BabylonNativeInterop_refresh(JNIEnv* env, jclass obj, jlong instanceRef, jobject surface)
{
    auto native = reinterpret_cast<Babylon::Native*>(instanceRef);
    ANativeWindow* windowPtr = ANativeWindow_fromSurface(env, surface);
    native->Refresh(windowPtr);
}

extern "C" JNIEXPORT void JNICALL Java_com_reactlibrary_BabylonNativeInterop_setPointerButtonState(JNIEnv* env, jclass obj, jlong instanceRef, jint pointerId, jint buttonId, jboolean isDown, jint x, jint y)
{
    auto native = reinterpret_cast<Babylon::Native*>(instanceRef);
    native->SetPointerButtonState(static_cast<uint32_t>(pointerId), static_cast<uint32_t>(buttonId), isDown, static_cast<uint32_t>(x), static_cast<uint32_t>(y));
}

extern "C" JNIEXPORT void JNICALL Java_com_reactlibrary_BabylonNativeInterop_setPointerPosition(JNIEnv* env, jclass obj, jlong instanceRef, jint pointerId, jint x, jint y)
{
    auto native = reinterpret_cast<Babylon::Native*>(instanceRef);
    native->SetPointerPosition(static_cast<uint32_t>(pointerId), static_cast<uint32_t>(x), static_cast<uint32_t>(y));
}

extern "C" JNIEXPORT void JNICALL Java_com_reactlibrary_BabylonNativeInterop_destroy(JNIEnv* env, jclass obj, jlong instanceRef)
{
    auto native = reinterpret_cast<Babylon::Native*>(instanceRef);
    delete native;

    g_jsiRuntime.reset();
}

extern "C" JNIEXPORT void JNICALL Java_com_reactlibrary_BabylonNativeInterop_testJSI(JNIEnv* env, jclass obj, jlong jsRuntimeHandle)
{
    using namespace facebook;
    auto &jsiRuntime = *(jsi::Runtime*)jsRuntimeHandle;

    // Global variable
    {
        jsiRuntime.global().setProperty(jsiRuntime, "testValue", jsi::Value(42));
    }
//
//    // Global object
//    {
//        jsi::Object testObj(jsiRuntime);
//        testObj.setProperty(jsiRuntime, "testProperty", jsi::Value(jsiRuntime, jsi::String::createFromAscii(jsiRuntime, "this is a test property")));
//        jsiRuntime.global().setProperty(jsiRuntime, "testObject", std::move(testObj));
//    }
//
//    // Global function
//    {
//        auto testFunction = jsi::Function::createFromHostFunction(jsiRuntime, jsi::PropNameID::forAscii(jsiRuntime, "testFunction"), 1, [](jsi::Runtime& runtime, const jsi::Value& thisValue, const jsi::Value* arguments, size_t count) -> jsi::Value
//        {
//            auto numberArg = arguments[0].asNumber();
//            return jsi::Value(numberArg * numberArg);
//        });
//        jsiRuntime.global().setProperty(jsiRuntime, "testFunction", std::move(testFunction));
//    }
//
//    // Callback
//    {
//        auto testFunction = jsi::Function::createFromHostFunction(jsiRuntime, jsi::PropNameID::forAscii(jsiRuntime, "testCallback"), 1, [](jsi::Runtime& runtime, const jsi::Value& thisValue, const jsi::Value* arguments, size_t count) -> jsi::Value
//        {
//            auto callback = arguments[0].asObject(runtime).asFunction(runtime);
//            callback.call(runtime, "string passed from C++");
//            return nullptr;
//        });
//        jsiRuntime.global().setProperty(jsiRuntime, "testCallback", std::move(testFunction));
//    }
//
//    // Class
//    {
//        auto classFactoryCode = std::make_shared<const jsi::StringBuffer>("(function(constructor) { return function() { return constructor.apply(this, arguments); }; })");
//        auto createClass = jsiRuntime.evaluateJavaScript(std::move(classFactoryCode), "class factory").asObject(jsiRuntime).asFunction(jsiRuntime);
//
//        auto testClass = createClass.call(jsiRuntime, jsi::Function::createFromHostFunction(jsiRuntime, jsi::PropNameID::forAscii(jsiRuntime, "TestClass.ctor"), 1, [](jsi::Runtime& runtime, const jsi::Value& thisValue, const jsi::Value* arguments, size_t count) -> jsi::Value
//        {
//            auto testObj = thisValue.asObject(runtime);
//            testObj.setProperty(runtime, "testProperty1", std::move(arguments[0]));
//            return nullptr;
//        })).asObject(jsiRuntime);
//
//        auto testClassPrototype = testClass.getProperty(jsiRuntime, "prototype").asObject(jsiRuntime);
//        testClassPrototype.setProperty(jsiRuntime, "testProperty2", 55);
//        testClassPrototype.setProperty(jsiRuntime, "testFunction", jsi::Function::createFromHostFunction(jsiRuntime, jsi::PropNameID::forAscii(jsiRuntime, "testFunction"), 0, [](jsi::Runtime& runtime, const jsi::Value& thisValue, const jsi::Value* arguments, size_t count) -> jsi::Value
//        {
//            thisValue.asObject(runtime).setProperty(runtime, "testProperty2", 66);
//            return jsi::Value(runtime, jsi::String::createFromAscii(runtime, "this is a test function"));
//        }));
//
//        jsiRuntime.global().setProperty(jsiRuntime, "TestClass", std::move(testClass));
//    }
}
