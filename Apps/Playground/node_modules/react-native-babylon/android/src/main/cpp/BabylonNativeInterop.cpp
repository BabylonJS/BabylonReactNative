#include <jni.h>

#include <Babylon/JsRuntime.h>
#include <Babylon/NativeWindow.h>
#include <Babylon/NativeEngine.h>

#include <arcana/threading/task_schedulers.h>

#include <JavaScriptCore/JavaScript.h>

#include <android/log.h>
#include <android/looper.h>
#include <android/native_window.h>
#include <android/native_window_jni.h>

#include <optional>
#include <sstream>
#include <unistd.h>

namespace Babylon
{
    namespace
    {
        void log(const char *str)
        {
            __android_log_print(ANDROID_LOG_VERBOSE, "BabylonNative", "%s", str);
        }
    }

    class Native final
    {
    public:
        // This class must be constructed from the JavaScript thread
        Native(JSGlobalContextRef jsContext, ANativeWindow* windowPtr)
        {
            m_env = std::make_shared<Napi::Env>(Napi::Attach(jsContext));
            m_looper_scheduler = std::make_shared<looper_scheduler_t>(looper_scheduler_t::get_for_current_thread());

            JsRuntime::DispatchFunctionT dispatchFunction{[weak_env = std::weak_ptr<Napi::Env>(m_env), weak_looper_scheduler = std::weak_ptr<looper_scheduler_t>(m_looper_scheduler)](std::function<void(Napi::Env)> func) {
                auto looper_scheduler = weak_looper_scheduler.lock();
                if (looper_scheduler)
                {
                    (*looper_scheduler)([weak_env, func = std::move(func)]()
                    {
                        auto env = weak_env.lock();
                        if (env)
                        {
                            func(*env);
                        }
                    });
                }
            }};

            JsRuntime::CreateForJavaScript(*m_env, dispatchFunction);

            auto width = static_cast<size_t>(ANativeWindow_getWidth(windowPtr));
            auto height = static_cast<size_t>(ANativeWindow_getHeight(windowPtr));

            InitializeGraphics(windowPtr, width, height);
            InitializeNativeEngine(*m_env);
            NativeWindow::Initialize(*m_env, windowPtr, width, height);
        }

        ~Native()
        {
            DeinitializeGraphics();
        }

        void Refresh(ANativeWindow* windowPtr)
        {
            auto width = static_cast<size_t>(ANativeWindow_getWidth(windowPtr));
            auto height = static_cast<size_t>(ANativeWindow_getHeight(windowPtr));
            ReinitializeNativeEngine(*m_env, windowPtr, width, height);
        }

    private:
        void Dispatch(std::function<void(Napi::Env)> func){}

    private:
        using looper_scheduler_t = arcana::looper_scheduler<sizeof(std::weak_ptr<Napi::Env>) + sizeof(std::function<void(Napi::Env)>)>;
        std::shared_ptr<looper_scheduler_t> m_looper_scheduler;
        std::shared_ptr<Napi::Env> m_env;
    };
}

extern "C" JNIEXPORT jlong JNICALL Java_com_reactlibrary_BabylonNativeInterop_create(JNIEnv* env, jclass obj, jlong jsContextRef, jobject surface)
{
    auto jsContext = reinterpret_cast<JSGlobalContextRef>(jsContextRef);
    ANativeWindow* windowPtr = ANativeWindow_fromSurface(env, surface);
    auto native = new Babylon::Native(jsContext, windowPtr);
    return reinterpret_cast<intptr_t>(native);
}

extern "C" JNIEXPORT void JNICALL Java_com_reactlibrary_BabylonNativeInterop_refresh(JNIEnv* env, jclass obj, jlong instanceRef, jobject surface)
{
    auto native = reinterpret_cast<Babylon::Native*>(instanceRef);
    ANativeWindow* windowPtr = ANativeWindow_fromSurface(env, surface);
    native->Refresh(windowPtr);
}

extern "C" JNIEXPORT void JNICALL Java_com_reactlibrary_BabylonNativeInterop_destroy(JNIEnv* env, jclass obj, jlong instanceRef)
{
    auto native = reinterpret_cast<Babylon::Native*>(instanceRef);
    delete native;
}