import { useEffect } from 'react';
import { Engine, NativeEngine } from '@babylonjs/core';
import { BabylonModule } from './BabylonModule';
import { DisposeEngine } from './EngineHelpers';

export async function useEngine(engineCallback: (engine: Engine) => void) {
    useEffect(() => {
        let engine: NativeEngine | null = null;
        const status = { disposed: false };

        (async () => {
            if (await BabylonModule.initialize() && !status.disposed)
            {
                // TEMP HACK: Override this because Babylon Native uses the presence of window.requestAnimationFrame to decide whether to run the native or JS code path, but React Native polyfills window.requestAnimationFrame.
                (NativeEngine.prototype as any)._queueNewFrame = function (bindedRenderFunction: any, requester: any) {
                    this._native.requestAnimationFrame(bindedRenderFunction);
                    return 0;
                };

                engineCallback(engine = new NativeEngine());
            }
        })();

        return () => {
            status.disposed = true;
            if (engine) {
                DisposeEngine(engine);
            }
        };
    }, []);
}