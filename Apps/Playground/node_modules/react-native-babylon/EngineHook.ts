import { useEffect, useState } from 'react';
import { Platform } from 'react-native';
import { PERMISSIONS, check, request } from 'react-native-permissions';
import { Engine, NativeEngine, WebXRSessionManager } from '@babylonjs/core';
import { BabylonModule } from './BabylonModule';
import { DisposeEngine } from './EngineHelpers';

declare const window: any;

// These are errors that are normally thrown by WebXR's requestSession, so we should throw the same errors under similar circumstances so app code can be written the same for browser or native.
// https://developer.mozilla.org/en-US/docs/Web/API/XRSystem/requestSession
// https://developer.mozilla.org/en-US/docs/Web/API/DOMException#Error_names
enum DOMError {
    NotSupportedError = 9,
    InvalidStateError = 11,
    SecurityError = 18,
}

class DOMException {
    public constructor(private readonly error: DOMError) { }
    get code(): number { return this.error; }
    get name(): string { return DOMError[this.error]; }
}

export function useEngine(): Engine | undefined {
    const [engine, setEngine] = useState<Engine>();

    useEffect(() => {
        let engine: Engine | undefined;
        let disposed = false;

        (async () => {
            if (await BabylonModule.initialize() && !disposed)
            {
                // TEMP HACK: Override this because Babylon Native uses the presence of window.requestAnimationFrame to decide whether to run the native or JS code path, but React Native polyfills window.requestAnimationFrame.
                (NativeEngine.prototype as any)._queueNewFrame = function (bindedRenderFunction: any, requester: any) {
                    if (requester.requestAnimationFrame && requester !== window) {
                        requester.requestAnimationFrame(bindedRenderFunction);
                    } else {
                        this._native.requestAnimationFrame(bindedRenderFunction);
                    }
                    return 0;
                };

                const originalInitializeSessionAsync: (...args: any[]) => Promise<any> = WebXRSessionManager.prototype.initializeSessionAsync;
                WebXRSessionManager.prototype.initializeSessionAsync = async function (...args: any[]): Promise<any> {
                    const cameraPermission = Platform.select({
                        android: PERMISSIONS.ANDROID.CAMERA,
                        ios: PERMISSIONS.IOS.CAMERA,
                    });

                    if (cameraPermission === undefined) {
                        throw new DOMException(DOMError.NotSupportedError);
                    }

                    let permissionStatus = await check(cameraPermission);
                    if (permissionStatus == "denied")
                    {
                        permissionStatus = await request(cameraPermission);
                    }

                    switch(permissionStatus) {
                        case "unavailable":
                            throw new DOMException(DOMError.NotSupportedError);
                        case "denied":
                        case "blocked":
                            throw new DOMException(DOMError.SecurityError);
                        case "granted":
                            return originalInitializeSessionAsync.apply(this, args);
                    }
                }

                setEngine(engine = new NativeEngine());
            }
        })();

        return () => {
            disposed = true;
            if (engine) {
                DisposeEngine(engine);
            }
        };
    }, []);

    return engine;
}