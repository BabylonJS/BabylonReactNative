import { useEffect, EffectCallback, DependencyList, useState } from 'react';
import { Engine, NativeEngine } from '@babylonjs/core';
import { BabylonModule } from './BabylonModule';
import { DisposeEngine } from './EngineHelpers';

export type AsyncEffectCallbackResult = void | (() => void) | (() => Promise<void>);
export type AsyncEffectCallback = (abortSignal: AbortSignal) => Promise<AsyncEffectCallbackResult>

export function useAsyncEffect(effect: AsyncEffectCallback, deps?: DependencyList) {
    useEffect(() => {
        const abortController = new AbortController();
        let cleanup: AsyncEffectCallbackResult;

        (async () => {
            cleanup = await effect(abortController.signal);
            if (abortController.signal.aborted && (cleanup !== undefined)) {
                await cleanup();
            }
        })();

        return () => {
            abortController.abort();
            if (cleanup) {
                (async () => {
                    await cleanup();
                })();
            }
        };

    }, deps);
}

export function useEngine(): Engine | undefined {
    const [engine, setEngine] = useState<Engine>();

    useEffect(() => {
        let engine: Engine | undefined;
        let disposed = false;

        (async () => {
            if (await BabylonModule.initialize() && !disposed)
            {
                // TEMP HACK: Override this because Babylon Native uses the presence of window.requestAnimationFrame to decide whether to run the native or JS code path, but React Native polyfills window.requestAnimationFrame.
                (NativeEngine.prototype as any)._queueNewFrame = function (bindedRenderFunction: any, requester: any) {
                    this._native.requestAnimationFrame(bindedRenderFunction);
                    return 0;
                };

                setEngine(engine = new NativeEngine());
            }
        })();

        return () => {
            disposed = true;
            if (engine) {
                DisposeEngine(engine);
            }
        };
    }, []);

    return engine;
}

// still need to return a cleanup function for the case where it is not aborted
export async function useEngine_2(engineCallback: (engine: Engine, abortSignal: AbortSignal) => void | Promise<void>) {
    useEffect(() => {
        let engine: NativeEngine | null = null;
        const abortController = new AbortController();

        (async () => {
            if (await BabylonModule.initialize() && !abortController.signal.aborted)
            {
                // TEMP HACK: Override this because Babylon Native uses the presence of window.requestAnimationFrame to decide whether to run the native or JS code path, but React Native polyfills window.requestAnimationFrame.
                (NativeEngine.prototype as any)._queueNewFrame = function (bindedRenderFunction: any, requester: any) {
                    this._native.requestAnimationFrame(bindedRenderFunction);
                    return 0;
                };

                await engineCallback(engine = new NativeEngine(), abortController.signal);
            }
        })();

        return () => {
            abortController.abort();
            if (engine) {
                DisposeEngine(engine);
            }
        };
    }, []);
}

export async function useEngine_1(engineCallback: (engine: Engine) => (void | (() => void | undefined))) {
    useEffect(() => {
        let engine: NativeEngine | null = null;
        const state: {
            disposed: boolean,
            cleanup?: void | (() => void),
        } = {
            disposed: false,
        };

        (async () => {
            if (await BabylonModule.initialize() && !state.disposed)
            {
                // TEMP HACK: Override this because Babylon Native uses the presence of window.requestAnimationFrame to decide whether to run the native or JS code path, but React Native polyfills window.requestAnimationFrame.
                (NativeEngine.prototype as any)._queueNewFrame = function (bindedRenderFunction: any, requester: any) {
                    this._native.requestAnimationFrame(bindedRenderFunction);
                    return 0;
                };

                state.cleanup = engineCallback(engine = new NativeEngine());
            }
        })();

        return () => {
            state.disposed = true;
            if (engine) {
                if (state.cleanup) {
                    state.cleanup();
                }
                DisposeEngine(engine);
            }
        };
    }, []);
}